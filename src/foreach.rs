use crate::{Tuple, TupleLike, Unit};

/// Define functors for traversing the tuple.
///
/// To traverse a tuple with type `Tuple<T0, T1, ... Tn>`, you need to construct a custom functor type,
/// which implements [`Mapper<T0>`], [`Mapper<T1>`] ... [`Mapper<Tn>`].
/// Pass your functor to tuple's [`map()`](TupleLike::map()) method, then the tuple will call
/// functor's [`map()`](Mapper::map()) method in order of its elements and move the elements in.
///
/// NOTE: Traversing a tuple will consume it. If this is not what you want, call [`as_ref()`](TupleLike::as_ref())
/// or [`as_mut()`](TupleLike::as_mut()) to create a new tuple that references its all members before traversing.
///
/// # The [`mapper!`] macro
///
/// There is a [`mapper!`] macro that helps you build a functor simply, here is an example:
///
/// ```
/// use tuplez::*;
///
/// let tup = tuple!(1, "hello", 3.14).map(mapper!{
///     |x: i32| -> i64 { x as i64 }
///     |x: f32| -> String { x.to_string() }
///     <'a> |x: &'a str| -> &'a [u8] { x.as_bytes() }
/// });
/// assert_eq!(tup, tuple!(1i64, b"hello" as &[u8], "3.14".to_string()));
/// ```
///
/// Check the documentation page of [`mapper!`] for detailed syntax.
///
///
/// # Custom functor
///
/// For more complex cases that cannot be covered by the [`mapper!`] macro, for example, you want to save some results
/// inside your functor, you need to implement [`Mapper<Ti>`] for your functor for all element type `Ti`s in tuples.
/// Generic can be used.
///
/// For example:
///
/// ```
/// use tuplez::*;
///
/// struct MyElement(i32);
///
/// #[derive(Default)]
/// struct Collector(Vec<String>);
///
/// impl<T: ToString> Mapper<&T> for Collector {
///     type Output = ();
///     fn map(&mut self, value: &T) -> Self::Output {
///         self.0.push(format!(
///             "{} : {}",
///             std::any::type_name::<T>(),
///             value.to_string()
///         ))
///     }
/// }
///
/// impl Mapper<&MyElement> for Collector {
///     type Output = ();
///     fn map(&mut self, value: &MyElement) -> Self::Output {
///         self.0.push(format!("MyElement : {}", value.0))
///     }
/// }
///
/// let mut collector = Collector::default();
/// tuple!(1, "hello", MyElement(14)).as_ref().map(&mut collector);
/// assert_eq!(
///     collector.0,
///     vec![
///         "i32 : 1".to_string(),
///         "&str : hello".to_string(),
///         "MyElement : 14".to_string()
///     ]
/// );
/// ```
pub trait Mapper<T> {
    /// Output type of mapping.
    type Output;

    /// Map an element to another value through its immutable reference.
    fn map(&mut self, value: T) -> Self::Output;
}

/// Traverse the tuple by immutable references to its elements.
///
/// # The Functor `F`
///
/// For traversing `Tuple<T0, T1, ... Tn>`, you need to construct a custom functor type,
/// which needs to implement [`Mapper<T0>`], [`Mapper<T1>`] ... [`Mapper<Tn>`].
///
/// See the documentation page of [`Mapper`] for details.
pub trait Foreach<F> {
    /// The type of tuple generated by traversing the tuple.
    type Output: TupleLike;

    /// Traverse the tuple by immutable references to its elements,
    /// and collect the output of traversal into a new tuple.
    ///
    /// NOTE: Traversing a tuple will consume it. If this is not what you want, call [`as_ref()`](TupleLike::as_ref())
    /// or [`as_mut()`](TupleLike::as_mut()) to create a new tuple that references its all members before traversing.
    ///
    /// The [`TupleLike`] trait provides the [`map()`](TupleLike::map()) method as the wrapper for the [`foreach()`](Foreach::foreach()) method.
    ///
    /// # Example
    ///
    /// ```
    /// use tuplez::*;
    ///
    /// let tup = tuple!(1, "hello", 3.14).foreach(mapper!{
    ///     |x: i32| -> i64 { x as i64 }
    ///     |x: f32| -> String { x.to_string() }
    ///     <'a> |x: &'a str| -> &'a [u8] { x.as_bytes() }
    /// });
    /// assert_eq!(tup, tuple!(1i64, b"hello" as &[u8], "3.14".to_string()));
    /// ```
    fn foreach(self, f: &mut F) -> Self::Output;
}

impl<F> Foreach<F> for Unit {
    type Output = Unit;
    fn foreach(self, _: &mut F) -> Self::Output {
        Unit
    }
}

impl<F, First, Other> Foreach<F> for Tuple<First, Other>
where
    F: Mapper<First>,
    Other: Foreach<F>,
{
    type Output = Tuple<<F as Mapper<First>>::Output, <Other as Foreach<F>>::Output>;
    fn foreach(self, f: &mut F) -> Self::Output {
        Tuple(f.map(self.0), self.1.foreach(f))
    }
}
