//! Provides some operations between two tuples.
//!
//! The module aims to hide the implementation details, all methods are wrapped by [`TupleLike`].

use crate::{tuple, tuple_t, Tuple, TupleLike, Unit};
use std::ops::{Add, Mul};

/// Pop elements from the front and back of the tuple.
///
/// The [`Unit`] type is not [`Popable`]. All [`Tuple`]s are [`Popable`].
///
/// The [`take!`](crate::take!) macro provides another way to take out elements by their indexes or types.
pub trait Popable: TupleLike {
    /// The type of tuple generated by popping an element from the front of the tuple.
    type PopFrontOutput: TupleLike;

    /// The type of the element popped from the front of the tuple.
    type PopFrontElement;

    /// The type of tuple generated by popping an element from the back of the tuple.
    type PopBackOutput: TupleLike;

    /// The type of the element popped from the back of the tuple.
    type PopBackElement;

    /// Pop an element from the back of the tuple.
    ///
    /// Hint: The [`TupleLike`] trait provides the [`pop()`](TupleLike::pop()) method as the wrapper
    /// for this [`pop()`](Popable::pop()) method.
    ///
    /// # Examples
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, "hello", 3.14);
    /// let (tup2, popped) = tup.pop();
    /// assert_eq!(tup2, tuple!(1, "hello"));
    /// assert_eq!(popped, 3.14);
    /// ```
    fn pop(self) -> (Self::PopBackOutput, Self::PopBackElement);

    /// Pop an element from the front of the tuple.
    ///
    /// Hint: The [`TupleLike`] trait provides the [`pop_front()`](TupleLike::pop_front()) method as the wrapper
    /// for this [`pop_front()`](Popable::pop_front()) method.
    ///
    /// # Examples
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, "hello", 3.14);
    /// let (tup2, popped) = tup.pop_front();
    /// assert_eq!(tup2, tuple!("hello", 3.14));
    /// assert_eq!(popped, 1);
    /// ```
    fn pop_front(self) -> (Self::PopFrontOutput, Self::PopFrontElement);

    /// Pop an element from the back of the tuple. Same as [`pop()`](Popable::pop()).
    ///
    /// Hint: The [`TupleLike`] trait provides the [`pop_back()`](TupleLike::pop_back()) method as the wrapper
    /// for this [`pop_back()`](Popable::pop_back()) method.
    fn pop_back(self) -> (Self::PopBackOutput, Self::PopBackElement);
}

impl<First, Other> Popable for Tuple<First, Other>
where
    Other: Popable + TupleLike,
{
    type PopFrontOutput = Other;
    type PopFrontElement = First;
    type PopBackOutput = Tuple<First, Other::PopBackOutput>;
    type PopBackElement = Other::PopBackElement;

    fn pop(self) -> (Self::PopBackOutput, Self::PopBackElement) {
        let (tup, elem) = Popable::pop(self.1);
        (Tuple(self.0, tup), elem)
    }

    fn pop_front(self) -> (Self::PopFrontOutput, Self::PopFrontElement) {
        (self.1, self.0)
    }

    fn pop_back(self) -> (Self::PopBackOutput, Self::PopBackElement) {
        Popable::pop(self)
    }
}

impl<First> Popable for Tuple<First, Unit> {
    type PopFrontOutput = Unit;
    type PopFrontElement = First;
    type PopBackOutput = Unit;
    type PopBackElement = First;
    fn pop(self) -> (Self::PopBackOutput, Self::PopBackElement) {
        (Unit, self.0)
    }

    fn pop_front(self) -> (Self::PopFrontOutput, Self::PopFrontElement) {
        (Unit, self.0)
    }

    fn pop_back(self) -> (Self::PopBackOutput, Self::PopBackElement) {
        Popable::pop(self)
    }
}

/// Rotate the elements of the tuple.
pub trait Rotatable: TupleLike {
    /// The type of tuple generated by left rorating the elements of the tuple.
    type RotLeftOutput: TupleLike;

    /// The type of tuple generated by right rotating the elements of the tuple.
    type RotRightOutput: TupleLike;

    /// Left rotates the elements of the tuple.
    ///
    /// # Examples
    /// 
    /// Hint: The [`TupleLike`] trait provides the [`rot_l()`](TupleLike::rot_l()) method as the wrapper
    /// for this [`rot_l()`](Rotatable::rot_l()) method.
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, "2", 3.0, 4);
    /// let tup2 = tup.rot_l();
    /// assert_eq!(tup2, tuple!("2", 3.0, 4, 1));
    /// ```
    fn rot_l(self) -> Self::RotLeftOutput;

    /// Right rotates the elements of the tuple.
    ///
    /// # Examples
    /// 
    /// Hint: The [`TupleLike`] trait provides the [`rot_r()`](TupleLike::rot_r()) method as the wrapper
    /// for this [`rot_r()`](Rotatable::rot_r()) method.
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, "2", 3.0, 4);
    /// let tup2 = tup.rot_r();
    /// assert_eq!(tup2, tuple!(4, 1, "2", 3.0));
    /// ```
    fn rot_r(self) -> Self::RotRightOutput;
}

impl Rotatable for Unit {
    type RotLeftOutput = Unit;
    type RotRightOutput = Unit;

    fn rot_l(self) -> Unit {
        self
    }

    fn rot_r(self) -> Unit {
        self
    }
}

impl<First, Other> Rotatable for Tuple<First, Other>
where
    Other: TupleLike,
    Self: Popable,
{
    type RotLeftOutput = Other::PushBackOutput<First>;
    type RotRightOutput =
        Tuple<<Self as Popable>::PopBackElement, <Self as Popable>::PopBackOutput>;

    fn rot_l(self) -> Self::RotLeftOutput {
        let Tuple(first, other) = self;
        other.push(first)
    }

    fn rot_r(self) -> Self::RotRightOutput {
        let (out, elem) = Popable::pop(self);
        Tuple(elem, out)
    }
}

/// Dot product operation.
pub trait Dot<T = Self> {
    /// Output type of the dot product operation.
    type Output;

    /// Performs the dot product operation.
    fn dot(self, rhs: T) -> Self::Output;
}

impl Dot for Unit {
    type Output = Unit;
    fn dot(self, _: Self) -> Self::Output {
        Self
    }
}

impl<First1, Other1, First2, Other2> Dot<Tuple<First2, Other2>> for Tuple<First1, Other1>
where
    First1: Mul<First2>,
    Other1: Dot<Other2> + TupleLike,
    Other2: TupleLike,
    <Other1 as Dot<Other2>>::Output: Add<<First1 as Mul<First2>>::Output>,
{
    type Output = <<Other1 as Dot<Other2>>::Output as Add<<First1 as Mul<First2>>::Output>>::Output;
    fn dot(self, rhs: Tuple<First2, Other2>) -> Self::Output {
        Dot::dot(self.1, rhs.1) + self.0 * rhs.0
    }
}

/// Zip two tuples.
pub trait Zippable<T>: TupleLike {
    /// The type of the output generated by zipping two tuples.
    type Output: TupleLike;

    /// The type of the output generated by zipping two tuples, but elements are primitive tuples.
    type Output2: TupleLike;

    /// Zip two tuples.
    ///
    /// Hint: The [`TupleLike`] trait provides the [`zip()`](TupleLike::zip()) method as the wrapper
    /// for this [`zip()`](Zippable::zip()) method.
    ///
    /// # Example
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, 2.0, "3").zip(tuple!("4", 5, 6.0));
    /// assert_eq!(tup, tuple!(tuple!(1, "4"), tuple!(2.0, 5), tuple!("3", 6.0)));
    /// ```
    fn zip(self, rhs: T) -> Self::Output;

    /// Zip two tuples, but output elements are primitive tuples.
    ///
    /// Hint: The [`TupleLike`] trait provides the [`zip2()`](TupleLike::zip2()) method as the wrapper
    /// for this [`zip2()`](Zippable::zip2()) method.
    ///
    /// # Example
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, 2.0, "3").zip2(tuple!("4", 5, 6.0));
    /// assert_eq!(tup, tuple!((1, "4"), (2.0, 5), ("3", 6.0)));
    /// ```
    fn zip2(self, rhs: T) -> Self::Output2;
}

impl Zippable<Unit> for Unit {
    type Output = Unit;
    type Output2 = Unit;

    fn zip(self, _: Unit) -> Self::Output {
        self
    }

    fn zip2(self, _: Unit) -> Self::Output2 {
        self
    }
}

impl<First1, Other1, First2, Other2> Zippable<Tuple<First2, Other2>> for Tuple<First1, Other1>
where
    Other1: Zippable<Other2> + TupleLike,
    Other2: TupleLike,
{
    type Output = Tuple<tuple_t!(First1, First2), <Other1 as Zippable<Other2>>::Output>;
    type Output2 = Tuple<(First1, First2), <Other1 as Zippable<Other2>>::Output2>;
    fn zip(self, rhs: Tuple<First2, Other2>) -> Self::Output {
        Tuple(
            tuple!(self.0, rhs.0),
            Zippable::zip(self.1, rhs.1),
        )
    }

    fn zip2(self, rhs: Tuple<First2, Other2>) -> Self::Output2 {
        Tuple((self.0, rhs.0), Zippable::zip2(self.1, rhs.1))
    }
}
