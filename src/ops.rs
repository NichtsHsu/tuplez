//! Provides some operations between two tuples.
//!
//! The module aims to hide the implementation details, all methods are wrapped by [`TupleLike`].

use crate::{tuple, tuple_t, Tuple, TupleLike, Unit};
use std::ops::{Add, Mul};

/// Dot product operation.
pub trait Dot<T = Self> {
    /// Output type of the dot product operation.
    type Output;

    /// Performs the dot product operation.
    fn dot(self, rhs: T) -> Self::Output;
}

impl Dot for Unit {
    type Output = Unit;
    fn dot(self, _: Self) -> Self::Output {
        Self
    }
}

impl<First1, Other1, First2, Other2> Dot<Tuple<First2, Other2>> for Tuple<First1, Other1>
where
    First1: Mul<First2>,
    Other1: Dot<Other2> + TupleLike,
    Other2: TupleLike,
    <Other1 as Dot<Other2>>::Output: Add<<First1 as Mul<First2>>::Output>,
{
    type Output = <<Other1 as Dot<Other2>>::Output as Add<<First1 as Mul<First2>>::Output>>::Output;
    fn dot(self, rhs: Tuple<First2, Other2>) -> Self::Output {
        Dot::<Other2>::dot(self.1, rhs.1) + self.0 * rhs.0
    }
}

/// Zip two tuples.
pub trait Zippable<T>: TupleLike {
    /// The type of the output generated by zipping two tuples.
    type Output: TupleLike;

    /// The type of the output generated by zipping two tuples, but elements are primitive tuples.
    type Output2: TupleLike;

    /// Zip two tuples.
    ///
    /// Hint: The [`TupleLike`] trait provides the [`zip()`](TupleLike::zip()) method as the wrapper
    /// for this [`zip()`](Zippable::zip()) method.
    /// 
    /// # Example
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, 2.0, "3").zip(tuple!("4", 5, 6.0));
    /// assert_eq!(tup, tuple!(tuple!(1, "4"), tuple!(2.0, 5), tuple!("3", 6.0)));
    /// ```
    fn zip(self, rhs: T) -> Self::Output;

    /// Zip two tuples, but output elements are primitive tuples.
    ///
    /// Hint: The [`TupleLike`] trait provides the [`zip2()`](TupleLike::zip2()) method as the wrapper
    /// for this [`zip2()`](Zippable::zip2()) method.
    /// 
    /// # Example
    ///
    /// ```
    /// use tuplez::{tuple, TupleLike};
    ///
    /// let tup = tuple!(1, 2.0, "3").zip2(tuple!("4", 5, 6.0));
    /// assert_eq!(tup, tuple!((1, "4"), (2.0, 5), ("3", 6.0)));
    /// ```
    fn zip2(self, rhs: T) -> Self::Output2;
}

impl Zippable<Unit> for Unit {
    type Output = Unit;
    type Output2 = Unit;

    fn zip(self, _: Unit) -> Self::Output {
        self
    }

    fn zip2(self, _: Unit) -> Self::Output2 {
        self
    }
}

impl<First1, Other1, First2, Other2> Zippable<Tuple<First2, Other2>> for Tuple<First1, Other1>
where
    Other1: Zippable<Other2> + TupleLike,
    Other2: TupleLike,
{
    type Output = Tuple<tuple_t!(First1, First2), <Other1 as Zippable<Other2>>::Output>;
    type Output2 = Tuple<(First1, First2), <Other1 as Zippable<Other2>>::Output2>;
    fn zip(self, rhs: Tuple<First2, Other2>) -> Self::Output {
        Tuple(
            tuple!(self.0, rhs.0),
            Zippable::<Other2>::zip(self.1, rhs.1),
        )
    }

    fn zip2(self, rhs: Tuple<First2, Other2>) -> Self::Output2 {
        Tuple((self.0, rhs.0), Zippable::<Other2>::zip2(self.1, rhs.1))
    }
}
